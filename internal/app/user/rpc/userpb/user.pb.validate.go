// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user.proto

package userpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Token) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TokenMultiError, or nil if none found.
func (m *Token) ValidateAll() error {
	return m.validate(true)
}

func (m *Token) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for ExpiredAt

	// no validation rules for RefreshAt

	if len(errors) > 0 {
		return TokenMultiError(errors)
	}

	return nil
}

// TokenMultiError is an error wrapping multiple validation errors returned by
// Token.ValidateAll() if the designated constraints aren't met.
type TokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMultiError) AllErrors() []error { return m }

// TokenValidationError is the validation error returned by Token.Validate if
// the designated constraints aren't met.
type TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenValidationError) ErrorName() string { return "TokenValidationError" }

// Error satisfies the builtin error interface
func (e TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenValidationError{}

// Validate checks the field values on UserRegisterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserRegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRegisterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserRegisterReqMultiError, or nil if none found.
func (m *UserRegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 6 || l > 32 {
		err := UserRegisterReqValidationError{
			field:  "Username",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 32 {
		err := UserRegisterReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetConfirmPassword()); l < 6 || l > 32 {
		err := UserRegisterReqValidationError{
			field:  "ConfirmPassword",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserRegisterReqMultiError(errors)
	}

	return nil
}

// UserRegisterReqMultiError is an error wrapping multiple validation errors
// returned by UserRegisterReq.ValidateAll() if the designated constraints
// aren't met.
type UserRegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRegisterReqMultiError) AllErrors() []error { return m }

// UserRegisterReqValidationError is the validation error returned by
// UserRegisterReq.Validate if the designated constraints aren't met.
type UserRegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRegisterReqValidationError) ErrorName() string { return "UserRegisterReqValidationError" }

// Error satisfies the builtin error interface
func (e UserRegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRegisterReqValidationError{}

// Validate checks the field values on UserRegisterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserRegisterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRegisterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserRegisterRespMultiError, or nil if none found.
func (m *UserRegisterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRegisterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserRegisterRespMultiError(errors)
	}

	return nil
}

// UserRegisterRespMultiError is an error wrapping multiple validation errors
// returned by UserRegisterResp.ValidateAll() if the designated constraints
// aren't met.
type UserRegisterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRegisterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRegisterRespMultiError) AllErrors() []error { return m }

// UserRegisterRespValidationError is the validation error returned by
// UserRegisterResp.Validate if the designated constraints aren't met.
type UserRegisterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRegisterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRegisterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRegisterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRegisterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRegisterRespValidationError) ErrorName() string { return "UserRegisterRespValidationError" }

// Error satisfies the builtin error interface
func (e UserRegisterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRegisterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRegisterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRegisterRespValidationError{}

// Validate checks the field values on UserUsernameLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserUsernameLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserUsernameLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserUsernameLoginReqMultiError, or nil if none found.
func (m *UserUsernameLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserUsernameLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 6 || l > 32 {
		err := UserUsernameLoginReqValidationError{
			field:  "Username",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 32 {
		err := UserUsernameLoginReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserUsernameLoginReqMultiError(errors)
	}

	return nil
}

// UserUsernameLoginReqMultiError is an error wrapping multiple validation
// errors returned by UserUsernameLoginReq.ValidateAll() if the designated
// constraints aren't met.
type UserUsernameLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserUsernameLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserUsernameLoginReqMultiError) AllErrors() []error { return m }

// UserUsernameLoginReqValidationError is the validation error returned by
// UserUsernameLoginReq.Validate if the designated constraints aren't met.
type UserUsernameLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserUsernameLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserUsernameLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserUsernameLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserUsernameLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserUsernameLoginReqValidationError) ErrorName() string {
	return "UserUsernameLoginReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserUsernameLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserUsernameLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserUsernameLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserUsernameLoginReqValidationError{}

// Validate checks the field values on UserUsernameLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserUsernameLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserUsernameLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserUsernameLoginRespMultiError, or nil if none found.
func (m *UserUsernameLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserUsernameLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserUsernameLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserUsernameLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserUsernameLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserUsernameLoginRespMultiError(errors)
	}

	return nil
}

// UserUsernameLoginRespMultiError is an error wrapping multiple validation
// errors returned by UserUsernameLoginResp.ValidateAll() if the designated
// constraints aren't met.
type UserUsernameLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserUsernameLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserUsernameLoginRespMultiError) AllErrors() []error { return m }

// UserUsernameLoginRespValidationError is the validation error returned by
// UserUsernameLoginResp.Validate if the designated constraints aren't met.
type UserUsernameLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserUsernameLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserUsernameLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserUsernameLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserUsernameLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserUsernameLoginRespValidationError) ErrorName() string {
	return "UserUsernameLoginRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserUsernameLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserUsernameLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserUsernameLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserUsernameLoginRespValidationError{}

// Validate checks the field values on UserSmsSendReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserSmsSendReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSmsSendReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserSmsSendReqMultiError,
// or nil if none found.
func (m *UserSmsSendReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSmsSendReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phone

	if len(errors) > 0 {
		return UserSmsSendReqMultiError(errors)
	}

	return nil
}

// UserSmsSendReqMultiError is an error wrapping multiple validation errors
// returned by UserSmsSendReq.ValidateAll() if the designated constraints
// aren't met.
type UserSmsSendReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSmsSendReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSmsSendReqMultiError) AllErrors() []error { return m }

// UserSmsSendReqValidationError is the validation error returned by
// UserSmsSendReq.Validate if the designated constraints aren't met.
type UserSmsSendReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSmsSendReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSmsSendReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSmsSendReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSmsSendReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSmsSendReqValidationError) ErrorName() string { return "UserSmsSendReqValidationError" }

// Error satisfies the builtin error interface
func (e UserSmsSendReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSmsSendReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSmsSendReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSmsSendReqValidationError{}

// Validate checks the field values on UserSmsSendResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSmsSendResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSmsSendResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSmsSendRespMultiError, or nil if none found.
func (m *UserSmsSendResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSmsSendResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserSmsSendRespMultiError(errors)
	}

	return nil
}

// UserSmsSendRespMultiError is an error wrapping multiple validation errors
// returned by UserSmsSendResp.ValidateAll() if the designated constraints
// aren't met.
type UserSmsSendRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSmsSendRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSmsSendRespMultiError) AllErrors() []error { return m }

// UserSmsSendRespValidationError is the validation error returned by
// UserSmsSendResp.Validate if the designated constraints aren't met.
type UserSmsSendRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSmsSendRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSmsSendRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSmsSendRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSmsSendRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSmsSendRespValidationError) ErrorName() string { return "UserSmsSendRespValidationError" }

// Error satisfies the builtin error interface
func (e UserSmsSendRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSmsSendResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSmsSendRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSmsSendRespValidationError{}

// Validate checks the field values on UserOneClickLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserOneClickLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserOneClickLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserOneClickLoginReqMultiError, or nil if none found.
func (m *UserOneClickLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserOneClickLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LoginToken

	// no validation rules for Platform

	if len(errors) > 0 {
		return UserOneClickLoginReqMultiError(errors)
	}

	return nil
}

// UserOneClickLoginReqMultiError is an error wrapping multiple validation
// errors returned by UserOneClickLoginReq.ValidateAll() if the designated
// constraints aren't met.
type UserOneClickLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOneClickLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOneClickLoginReqMultiError) AllErrors() []error { return m }

// UserOneClickLoginReqValidationError is the validation error returned by
// UserOneClickLoginReq.Validate if the designated constraints aren't met.
type UserOneClickLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOneClickLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOneClickLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOneClickLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOneClickLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOneClickLoginReqValidationError) ErrorName() string {
	return "UserOneClickLoginReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserOneClickLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOneClickLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOneClickLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOneClickLoginReqValidationError{}

// Validate checks the field values on UserOneClickLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserOneClickLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserOneClickLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserOneClickLoginRespMultiError, or nil if none found.
func (m *UserOneClickLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserOneClickLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserOneClickLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserOneClickLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserOneClickLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserOneClickLoginRespMultiError(errors)
	}

	return nil
}

// UserOneClickLoginRespMultiError is an error wrapping multiple validation
// errors returned by UserOneClickLoginResp.ValidateAll() if the designated
// constraints aren't met.
type UserOneClickLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOneClickLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOneClickLoginRespMultiError) AllErrors() []error { return m }

// UserOneClickLoginRespValidationError is the validation error returned by
// UserOneClickLoginResp.Validate if the designated constraints aren't met.
type UserOneClickLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOneClickLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOneClickLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOneClickLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOneClickLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOneClickLoginRespValidationError) ErrorName() string {
	return "UserOneClickLoginRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserOneClickLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOneClickLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOneClickLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOneClickLoginRespValidationError{}

// Validate checks the field values on UserSmsLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSmsLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSmsLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSmsLoginReqMultiError, or nil if none found.
func (m *UserSmsLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSmsLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phone

	// no validation rules for Code

	if len(errors) > 0 {
		return UserSmsLoginReqMultiError(errors)
	}

	return nil
}

// UserSmsLoginReqMultiError is an error wrapping multiple validation errors
// returned by UserSmsLoginReq.ValidateAll() if the designated constraints
// aren't met.
type UserSmsLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSmsLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSmsLoginReqMultiError) AllErrors() []error { return m }

// UserSmsLoginReqValidationError is the validation error returned by
// UserSmsLoginReq.Validate if the designated constraints aren't met.
type UserSmsLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSmsLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSmsLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSmsLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSmsLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSmsLoginReqValidationError) ErrorName() string { return "UserSmsLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e UserSmsLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSmsLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSmsLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSmsLoginReqValidationError{}

// Validate checks the field values on UserSmsLoginResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSmsLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSmsLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSmsLoginRespMultiError, or nil if none found.
func (m *UserSmsLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSmsLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSmsLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSmsLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSmsLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserSmsLoginRespMultiError(errors)
	}

	return nil
}

// UserSmsLoginRespMultiError is an error wrapping multiple validation errors
// returned by UserSmsLoginResp.ValidateAll() if the designated constraints
// aren't met.
type UserSmsLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSmsLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSmsLoginRespMultiError) AllErrors() []error { return m }

// UserSmsLoginRespValidationError is the validation error returned by
// UserSmsLoginResp.Validate if the designated constraints aren't met.
type UserSmsLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSmsLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSmsLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSmsLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSmsLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSmsLoginRespValidationError) ErrorName() string { return "UserSmsLoginRespValidationError" }

// Error satisfies the builtin error interface
func (e UserSmsLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSmsLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSmsLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSmsLoginRespValidationError{}

// Validate checks the field values on UserWechatAppLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWechatAppLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWechatAppLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWechatAppLoginReqMultiError, or nil if none found.
func (m *UserWechatAppLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWechatAppLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WechatCode

	if len(errors) > 0 {
		return UserWechatAppLoginReqMultiError(errors)
	}

	return nil
}

// UserWechatAppLoginReqMultiError is an error wrapping multiple validation
// errors returned by UserWechatAppLoginReq.ValidateAll() if the designated
// constraints aren't met.
type UserWechatAppLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWechatAppLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWechatAppLoginReqMultiError) AllErrors() []error { return m }

// UserWechatAppLoginReqValidationError is the validation error returned by
// UserWechatAppLoginReq.Validate if the designated constraints aren't met.
type UserWechatAppLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWechatAppLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWechatAppLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWechatAppLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWechatAppLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWechatAppLoginReqValidationError) ErrorName() string {
	return "UserWechatAppLoginReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserWechatAppLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWechatAppLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWechatAppLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWechatAppLoginReqValidationError{}

// Validate checks the field values on UserWechatAppLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWechatAppLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWechatAppLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWechatAppLoginRespMultiError, or nil if none found.
func (m *UserWechatAppLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWechatAppLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWechatAppLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWechatAppLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWechatAppLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserWechatAppLoginRespMultiError(errors)
	}

	return nil
}

// UserWechatAppLoginRespMultiError is an error wrapping multiple validation
// errors returned by UserWechatAppLoginResp.ValidateAll() if the designated
// constraints aren't met.
type UserWechatAppLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWechatAppLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWechatAppLoginRespMultiError) AllErrors() []error { return m }

// UserWechatAppLoginRespValidationError is the validation error returned by
// UserWechatAppLoginResp.Validate if the designated constraints aren't met.
type UserWechatAppLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWechatAppLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWechatAppLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWechatAppLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWechatAppLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWechatAppLoginRespValidationError) ErrorName() string {
	return "UserWechatAppLoginRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserWechatAppLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWechatAppLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWechatAppLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWechatAppLoginRespValidationError{}

// Validate checks the field values on UserQQAppLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserQQAppLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserQQAppLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserQQAppLoginReqMultiError, or nil if none found.
func (m *UserQQAppLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserQQAppLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QQCode

	if len(errors) > 0 {
		return UserQQAppLoginReqMultiError(errors)
	}

	return nil
}

// UserQQAppLoginReqMultiError is an error wrapping multiple validation errors
// returned by UserQQAppLoginReq.ValidateAll() if the designated constraints
// aren't met.
type UserQQAppLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserQQAppLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserQQAppLoginReqMultiError) AllErrors() []error { return m }

// UserQQAppLoginReqValidationError is the validation error returned by
// UserQQAppLoginReq.Validate if the designated constraints aren't met.
type UserQQAppLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserQQAppLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserQQAppLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserQQAppLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserQQAppLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserQQAppLoginReqValidationError) ErrorName() string {
	return "UserQQAppLoginReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserQQAppLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserQQAppLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserQQAppLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserQQAppLoginReqValidationError{}

// Validate checks the field values on UserQQAppLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserQQAppLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserQQAppLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserQQAppLoginRespMultiError, or nil if none found.
func (m *UserQQAppLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserQQAppLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserQQAppLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserQQAppLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserQQAppLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserQQAppLoginRespMultiError(errors)
	}

	return nil
}

// UserQQAppLoginRespMultiError is an error wrapping multiple validation errors
// returned by UserQQAppLoginResp.ValidateAll() if the designated constraints
// aren't met.
type UserQQAppLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserQQAppLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserQQAppLoginRespMultiError) AllErrors() []error { return m }

// UserQQAppLoginRespValidationError is the validation error returned by
// UserQQAppLoginResp.Validate if the designated constraints aren't met.
type UserQQAppLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserQQAppLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserQQAppLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserQQAppLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserQQAppLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserQQAppLoginRespValidationError) ErrorName() string {
	return "UserQQAppLoginRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserQQAppLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserQQAppLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserQQAppLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserQQAppLoginRespValidationError{}

// Validate checks the field values on UserAppleLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAppleLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAppleLoginReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAppleLoginReqMultiError, or nil if none found.
func (m *UserAppleLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAppleLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppleCode

	// no validation rules for NickName

	if len(errors) > 0 {
		return UserAppleLoginReqMultiError(errors)
	}

	return nil
}

// UserAppleLoginReqMultiError is an error wrapping multiple validation errors
// returned by UserAppleLoginReq.ValidateAll() if the designated constraints
// aren't met.
type UserAppleLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAppleLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAppleLoginReqMultiError) AllErrors() []error { return m }

// UserAppleLoginReqValidationError is the validation error returned by
// UserAppleLoginReq.Validate if the designated constraints aren't met.
type UserAppleLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAppleLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAppleLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAppleLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAppleLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAppleLoginReqValidationError) ErrorName() string {
	return "UserAppleLoginReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAppleLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAppleLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAppleLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAppleLoginReqValidationError{}

// Validate checks the field values on UserAppleLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAppleLoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAppleLoginResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAppleLoginRespMultiError, or nil if none found.
func (m *UserAppleLoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAppleLoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAppleLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAppleLoginRespValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAppleLoginRespValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UID

	if len(errors) > 0 {
		return UserAppleLoginRespMultiError(errors)
	}

	return nil
}

// UserAppleLoginRespMultiError is an error wrapping multiple validation errors
// returned by UserAppleLoginResp.ValidateAll() if the designated constraints
// aren't met.
type UserAppleLoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAppleLoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAppleLoginRespMultiError) AllErrors() []error { return m }

// UserAppleLoginRespValidationError is the validation error returned by
// UserAppleLoginResp.Validate if the designated constraints aren't met.
type UserAppleLoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAppleLoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAppleLoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAppleLoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAppleLoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAppleLoginRespValidationError) ErrorName() string {
	return "UserAppleLoginRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAppleLoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAppleLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAppleLoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAppleLoginRespValidationError{}

// Validate checks the field values on UserLoginOutReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLoginOutReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginOutReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLoginOutReqMultiError, or nil if none found.
func (m *UserLoginOutReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginOutReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UID

	if len(errors) > 0 {
		return UserLoginOutReqMultiError(errors)
	}

	return nil
}

// UserLoginOutReqMultiError is an error wrapping multiple validation errors
// returned by UserLoginOutReq.ValidateAll() if the designated constraints
// aren't met.
type UserLoginOutReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginOutReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginOutReqMultiError) AllErrors() []error { return m }

// UserLoginOutReqValidationError is the validation error returned by
// UserLoginOutReq.Validate if the designated constraints aren't met.
type UserLoginOutReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginOutReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginOutReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginOutReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginOutReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginOutReqValidationError) ErrorName() string { return "UserLoginOutReqValidationError" }

// Error satisfies the builtin error interface
func (e UserLoginOutReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginOutReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginOutReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginOutReqValidationError{}

// Validate checks the field values on UserLoginOutResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLoginOutResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginOutResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLoginOutRespMultiError, or nil if none found.
func (m *UserLoginOutResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginOutResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserLoginOutRespMultiError(errors)
	}

	return nil
}

// UserLoginOutRespMultiError is an error wrapping multiple validation errors
// returned by UserLoginOutResp.ValidateAll() if the designated constraints
// aren't met.
type UserLoginOutRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginOutRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginOutRespMultiError) AllErrors() []error { return m }

// UserLoginOutRespValidationError is the validation error returned by
// UserLoginOutResp.Validate if the designated constraints aren't met.
type UserLoginOutRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginOutRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginOutRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginOutRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginOutRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginOutRespValidationError) ErrorName() string { return "UserLoginOutRespValidationError" }

// Error satisfies the builtin error interface
func (e UserLoginOutRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginOutResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginOutRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginOutRespValidationError{}
